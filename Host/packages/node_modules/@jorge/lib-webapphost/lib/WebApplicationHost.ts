import * as express from "express";
import * as bp from "body-parser";
import * as cp from "cookie-parser";
import * as path from "path";
import * as logger from "morgan";
import "reflect-metadata";

import { debug } from "util";
import { Server } from "http";

import { Injectable, IContainer, Container, Inject } from "container-ioc";
import { Dictionary } from "typescript-collections";
import {
  createChildContainer,
  IServiceProvider,
  ServiceProvider,
  getGlobalServiceProvider,
  TServiceProvider
} from "@jorge/lib-di";
import {
  registerServiceProvider,
  getCurrentContainer
} from "@jorge/lib-di-express";

import {
  TDeviceDetection,
  IDeviceDetectionService,
  devicedetection
} from "@jorge/lib-devicedetection";

import {
  TMarketDetectionService,
  IMarketDetectionService,
  TMarketDetectionMiddleware
} from "@jorge/lib-marketdetection";

import { IWebApplicationHost } from "./interfaces";
import { middleware, TRouteProvider, IRoutingMiddleware } from "@jorge/lib-webapp-core";

@Injectable()
export class WebApplicationHost implements IWebApplicationHost {
  socket: Server;
  mainApplication: express.Application;

  /**
   *
   */
  public constructor(
    @Inject(TServiceProvider) private serviceProvider: IServiceProvider
  ) {
    this.mainApplication = express();

    this.mainApplication
      .use(logger("dev"))
      .use(bp.json())
      .use(bp.urlencoded({ extended: false }))
      .use(cp()); // cookie parser

    this.mainApplication.enable("trust proxy");

    // register middleware to create a child container for every request
    this.mainApplication.use(
      (
        req: express.Request,
        res: express.Response,
        next: express.NextFunction
      ) => {
        let childContainer: IContainer = createChildContainer();
        childContainer.register([
          {
            token: Symbol.for("Name"),
            useValue: "helloWorld"
          }
        ]);

        // TODO: add request information provider to chilc container

        registerServiceProvider(req, childContainer);

        next();
      }
    );

    this.mainApplication.use(devicedetection);

    this.mainApplication.use(middleware(TMarketDetectionMiddleware));
  }

  public start(port: number) {
    this.socket = this.mainApplication.listen(port, () => {
      console.info("Express Server Listening on port " + port);
    });
  }
  public initialize(): void {
    console.log("WebApplicationHost::initialize() >>");
    var routeProviders: IRoutingMiddleware[] = this.serviceProvider.getServices<IRoutingMiddleware>(TRouteProvider);

    var pathMap: Dictionary<string, IRoutingMiddleware[]> = new Dictionary<string,IRoutingMiddleware[]>();

    routeProviders.forEach(routeProvider => {
      if (!pathMap.containsKey(routeProvider.path)) {
        pathMap.setValue(routeProvider.path, [routeProvider]);
      } else {
        var routeProviderCollection = pathMap.getValue(routeProvider.path);
        routeProviderCollection.push(routeProvider);
      }
    });

    pathMap.keys().forEach(urlPath => {
      // don't add the root route for now
      if (urlPath == "/") return;

      console.log("Adding middleware for path [" + urlPath + "]");
      this.mainApplication.use(urlPath, (req, res, next) => {
        console.log("Resolving routes for: " + urlPath);

        var rpc = pathMap.getValue(urlPath);
        var executeNext: boolean = true;

        rpc.forEach(routeProvider => {
          if (routeProvider.shouldHandleRequest(req) && executeNext) {
            executeNext = routeProvider.handleRequest(req, res);
          }
        });

        if (executeNext) {
          next();
        }
      });
    });

    // add the root route
    var rpcRoot = pathMap.getValue("/");
    if (rpcRoot != null) {
      this.mainApplication.use("/", (req, res, next) => {
        console.log("Resolving routes for: " + "/");

        var executeNext: boolean = true;

        rpcRoot.forEach(routeProvider => {
          if (routeProvider.shouldHandleRequest(req) && executeNext) {
            executeNext = routeProvider.handleRequest(req, res);
          }
        });

        if (executeNext) {
          next();
        }
      });
    }

    console.log("WebApplicationHost::initialize() <<");
  }
}
