import * as express from "express";
import * as bp from "body-parser";
import * as cp from "cookie-parser";
import * as path from "path";
import * as logger from "morgan";
import "reflect-metadata";

import { debug } from "util";
import { Server } from "http";

import { IWebApplicationHost } from "./IWebApplicationHost";
import { IRouteProvider } from "./IRouteProvider";
import { TRouteProvider } from "./symbols";
import { Injectable, IContainer, Container, Inject } from "container-ioc";
import { Dictionary } from "typescript-collections";
import {
  createChildContainer,
  IServiceProvider,
  ServiceProvider,
  getGlobalServiceProvider,
  TServiceProvider
} from "@jorge/lib-di";
import {
  registerServiceProvider,
  getCurrentContainer
} from "@jorge/lib-di-express";

import {
  TDeviceDetection,
  IDeviceDetectionService
} from "@jorge/lib-devicedetection";

@Injectable()
export class WebApplicationHost implements IWebApplicationHost {
  socket: Server;
  mainApplication: express.Application;

  /**
   *
   */
  public constructor(
    @Inject(TServiceProvider) private serviceProvider: IServiceProvider
  ) {
    this.mainApplication = express();

    this.mainApplication
      .use(logger("dev"))
      .use(bp.json())
      .use(bp.urlencoded({ extended: false }))
      .use(cp()); // cookie parser

    // register middleware to create a child container for every request
    this.mainApplication.use(
      (
        req: express.Request,
        res: express.Response,
        next: express.NextFunction
      ) => {
        let childContainer: IContainer = createChildContainer();
        childContainer.register([
          {
            token: Symbol.for("Name"),
            useValue: "helloWorld"
          }
        ]);

        // TODO: add request information provider to chilc container

        registerServiceProvider(req, childContainer);

        next();
      }
    );

    this.mainApplication.use(
      (
        req: express.Request,
        res: express.Response,
        next: express.NextFunction
      ) => {
        var uaString: string = req.header("user-agent") as string;
        if (uaString != undefined) {
          var serviceProvider = getCurrentContainer(req);
          var deviceDetectionService = serviceProvider.getService<IDeviceDetectionService>(TDeviceDetection);

          var result = deviceDetectionService.parseUserAgent(uaString);

          console.log("Device: "+result.device+", os: "+result.os+", browser: "+result.browser);
        }

        next();
      }
    );

    // this.viewEngine = 'pug';
    // this.baseDirectory = __dirname;
    // this.viewsDirectory = 'views';
    // this.staticFilesDirectory = 'public';
  }

  public start(port: number) {
    this.socket = this.mainApplication.listen(port, () => {
      console.info("Express Server Listening on port " + port);
    });
  }
  public initialize(): void {
    // this.mainApplication.set('views', path.join(this.baseDirectory, this.viewsDirectory));
    // this.mainApplication.set('view engine', this.viewEngine);

    var routeProviders: IRouteProvider[] = this.serviceProvider.getServices<
      IRouteProvider
    >(TRouteProvider);

    var pathMap: Dictionary<string, IRouteProvider[]> = new Dictionary<
      string,
      IRouteProvider[]
    >();

    routeProviders.forEach(routeProvider => {
      if (!pathMap.containsKey(routeProvider.path)) {
        pathMap.setValue(routeProvider.path, [routeProvider]);
      } else {
        var routeProviderCollection = pathMap.getValue(routeProvider.path);
        routeProviderCollection.push(routeProvider);
      }
    });

    pathMap.forEach((urlPath, routeProviderCollection) => {
      this.mainApplication.use(urlPath, (req, res, next) => {
        var executeNext: boolean = true;

        routeProviderCollection.forEach(routeProvider => {
          if (routeProvider.shouldHandleRequest(req) && executeNext) {
            executeNext = false;
            routeProvider.handleRequest(req, res, next);
          }
        });

        if (executeNext) {
          next();
        }
      });
    });

    // TODO: group by path value
    routeProviders.forEach(routeProvider => {
      if (routeProvider != null) {
      }
    });
  }
}
